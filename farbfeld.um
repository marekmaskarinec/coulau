//////////////////////////////////////////////////////////////////////
//                                                                  //
// farbfeld.um - public domain farbfeld parser and writer           //
// by Marek Maskarinec                                              //
// https://github.com/marekmaskarinec/libs                          //
//                                                                  //
// How to use:                                                      //
//   get yourself a copy of std.um, change line 21 to import from   //
//   a correct path and import this file.                           //
//                                                                  //
// Return values:                                                   //
//   parse() returns four values. Data itself,                      //
//   width of the image, height of the image and                    //
//   an error code. You can compare them to constants               //
//   in this file. The data itself is an array of uints32           //
//   in format of 0xrrggbbaa. Iteration over it is shown            //
//   in the test.                                                   //
//                                                                  //
//////////////////////////////////////////////////////////////////////

import (
	"std.um" // change me for your std location
)

const (
	SUCCESS* = 0
	FILE_ERROR* = 1
	MAGIC_BYTE_ERROR* = 2
	WIDTH_ERROR* = 3
	HEIGHT_ERROR* = 4	
)

var counter: int

fn peekstr(f: std.File, next: int): str {
	tr := "" 
	for i:=0; i < next; i++ {
		var c: char
		fscanf(f, "%c", &c)
		tr += str(c)
		counter++
	}

	return tr
}

fn peekn(f: std.File, next: int): int {
	tr := 0
	for i:=0; i < next; i++ {
		var c: char 
		fscanf(f, "%c", &c)
		tr += int(c) << (8 * (next - i - 1))
		counter++
	}

	return tr
}

// loads image at path
fn load*(path: str): ([]uint32, int, int, int) {
	f := std.fopen(path, "r")
	if f == null {
		return []uint32{}, -1, -1, FILE_ERROR
	}
	var w, h: int
	var tr: []uint32
	counter = 0

	for i:=0; i < 18 {
		switch i {
		case 0:
			if val := peekstr(f, 8); val != "farbfeld" {
				return []uint32{}, -1, -1, MAGIC_BYTE_ERROR
			}
			i += 8
		case 8:
			w = peekn(f, 4)
			if w < 0 {
				return []uint32{}, -1, -1, WIDTH_ERROR
			}
			i += 4
		case 12:
			h = peekn(f, 4)
			if h < 0 {
				return []uint32{}, -1, -1, HEIGHT_ERROR
			}
			i += 4
		default:
			tr = make([]uint32, w * h)
			var c: char 
			for j:=0; j < w * h; j++ {
				for h:=0; h < 4; h++ {
					fscanf(f, "%c", &c)
					fscanf(f, "%c", &c)
					ic := int(c)
					if ic < 0 {
						ic += 256 
					}
					tr[j] += ic << (8 * (3 - h))
				}
			}
			break
		}
	}

	std.fclose(f)
	return tr, w, h, SUCCESS
}

fn tbend(inp: uint32): uint32 {
	var b0,b1,b2,b3: uint32

	b0 = (inp & 0x000000ff) << 24
	b1 = (inp & 0x0000ff00) << 8
	b2 = (inp & 0x00ff0000) >> 8
	b3 = (inp & 0xff000000) >> 24

	return b0 | b1 | b2 | b3
}

// writes a farbfeld file from data. w is width of the image
fn write*(path: str, data: []uint32, w: int): int {
	f := std.fopen(path, "w")
	if f == null {
		return FILE_ERROR
	}

	fprintf(f, "farbfeld")
	std.fwrite(f, tbend(uint32(w)))
	std.fwrite(f, tbend(uint32(len(data)/w)))
	for i:=0; i < len(data); i++ {
		for j:=0; j < 8; j++ {
			std.fwrite(f, char((data[i] | (0xff << (j/2 * 8))) >> 24))
		}
	}

	std.fclose(f)
	return SUCCESS
}
