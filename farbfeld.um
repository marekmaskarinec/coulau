//////////////////////////////////////////////////////////////////////
//                                                                  //
// farbfeld.um - public domain farbfeld parser and writer           //
// by Marek Maskarinec                                              //
// https://github.com/marekmaskarinec/libs                          //
//                                                                  //
// How to use:                                                      //
//   get yourself a copy of std.um, change line 21 to import from   //
//   a correct path and import this file.                           //
//                                                                  //
// Return values:                                                   //
//   parse() returns four values. Data itself,                      //
//   width of the image, height of the image and                    //
//   an error code. You can compare them to constants               //
//   in this file. The data itself is an array of uints32           //
//   in format of 0xrrggbbaa. Iteration over it is shown            //
//   in the test.                                                   //
//                                                                  //
//////////////////////////////////////////////////////////////////////

import (
	"std.um" // change me for your std location
)

const (
	SUCCESS* = 0
	FILE_ERROR* = 1
	MAGIC_BYTE_ERROR* = 2
)

fn peekstr(f: std.File, next: int): str {
	tr := "" 
	var c: char
	for i:=0; i < next; i++ {
		fscanf(f, "%c", &c)
		tr += str(c)
	}

	return tr
}

fn peekn(f: std.File, next: int): int {
	tr := 0
	var c: char 
	for i:=0; i < next; i++ {
		fscanf(f, "%c", &c)
		tr += int(c) << (8 * (next - i - 1))
	}

	return tr
}

// loads image at path
fn load*(path: str): ([]uint32, int, int, int) {
	f := std.fopen(path, "r")
	if f == null { return []uint32{}, -1, -1, FILE_ERROR }
	var w, h: int
	var tr: []uint32

	if val := peekstr(f, 8); val != "farbfeld" { return []uint32{}, -1, -1, MAGIC_BYTE_ERROR }
	w = peekn(f, 4)
	h = peekn(f, 4)
	tr = make([]uint32, w * h)
	var c: char 
	for j:=0; j < w * h; j++ {
		for h:=0; h < 4; h++ {
			fscanf(f, "%c", &c)
			fscanf(f, "%c", &c)
			ic := int(c)
			if ic < 0 { ic += 256 }
			tr[j] += ic << (8 * (3 - h))
		}
	}

	std.fclose(f)
	return tr, w, h, SUCCESS
}

fn tbend(inp: uint32): uint32 { return (inp & 0x000000ff) << 24 | (inp & 0x0000ff00) << 8 | (inp & 0x00ff0000) >> 8 | (inp & 0xff000000) >> 24 }

// splits a pixel into 4 uint8s
fn pixelsplit*(inp: uint32): (uint8, uint8, uint8, uint8) {
	var ps: [4]uint8
	for i:=0; i < 4; i++ { ps[i] = uint8(inp >> (24 - (i * 8)) & 0xff) }
	return ps[0], ps[1], ps[2], ps[3]
}

// merges r, g, b and a values into one
fn pixelmerge*(r, g, b, a: uint8): uint32 { return r << 24 | g << 16 | b << 8 | a }

// writes a farbfeld file from data. w is width of the image
fn write*(path: str, data: []uint32, w: int): int {
	f := std.fopen(path, "w")
	if f == null { return FILE_ERROR }

	fprintf(f, "farbfeld")
	std.fwrite(f, tbend(uint32(w)))
	std.fwrite(f, tbend(uint32(len(data)/w)))
	for i:=0; i < len(data); i++ {
		for j:=0; j < 8; j++ { std.fwrite(f, uint8(data[i] >> (24 - ((j / 2) * 8)) & 0xff)) }
	}

	std.fclose(f)
	return SUCCESS
}
