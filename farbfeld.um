//////////////////////////////////////////////////////////////////////
//                                                                  //
// farbfeld.um - public domain farbfeld parser                      //
// by Marek Maskarinec                                              //
// https://github.com/marekmaskarinec/libs                          //
//                                                                  //
// How to use:                                                      //
//   just import this.                                              //
//                                                                  //
// Return values:                                                   //
//   parse() returns four values. Data itself,                      //
//   width of the image, height of the image and                    //
//   an error code. You can compare them to constants               //
//   in this file. The data itself is an array of uints32           //
//   in format of 0xrrggbbaa. Iteration over it is shown            //
//   in the test.                                                   //
//                                                                  //
// NOTE: encoder coming soon                                        //
//                                                                  //
//////////////////////////////////////////////////////////////////////

import (
	"std.um"								
)

const (
	SUCCESS* = 0
	FILE_ERROR* = 1
	MAGIC_BYTE_ERROR* = 2
	WIDTH_ERROR* = 3
	HEIGHT_ERROR* = 4	
)

var counter: int

fn peekstr(f: std.File, next: int): str {
	tr := "" 
	for i:=0; i < next; i++ {
		var c: char
		fscanf(f, "%c", &c)
		tr += str(c)
		counter++
	}

	return tr
}

fn peekn(f: std.File, next: int): int {
	tr := 0
	for i:=0; i < next; i++ {
		var c: char 
		fscanf(f, "%c", &c)
		tr += int(c) << (8 * (next - i - 1))
		counter++
	}

	return tr
}

fn load*(path: str): ([]uint32, int, int, int) {
	f := std.fopen(path, "r")
	if f == null {
		return []uint32{}, -1, -1, FILE_ERROR
	}
	var w, h: int
	var tr: []uint32
	counter = 0

	for i:=0; i < 18 {
		switch i {
		case 0:
			if val := peekstr(f, 8); val != "farbfeld" {
				return []uint32{}, -1, -1, MAGIC_BYTE_ERROR
			}
			i += 8
		case 8:
			w = peekn(f, 4)
			if w < 0 {
				return []uint32{}, -1, -1, WIDTH_ERROR
			}
			i += 4
		case 12:
			h = peekn(f, 4)
			if h < 0 {
				return []uint32{}, -1, -1, HEIGHT_ERROR
			}
			i += 4
		default:
			tr = make([]uint32, w * h)
			var c: char 
			for j:=0; j < w * h; j++ {
				for h:=0; h < 4; h++ {
					fscanf(f, "%c", &c)
					fscanf(f, "%c", &c)
					ic := int(c)
					if ic < 0 {
						ic += 256 
					}
					tr[j] += ic << (8 * (3 - h))
				}
			}
			break
		}
	}

	return tr, w, h, SUCCESS
}
