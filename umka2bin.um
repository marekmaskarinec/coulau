//////////////////////////////////////////////////////
//                                                  //
// umka2bin.um - public domain umka to c coneverter //
// by Marek Maskarinec                              //
// https://github.com/marekmaskarinec/libs          //
//                                                  //
// How to use:                                      //
//   run this without any argument for help         //
//                                                  //
// TODO:                                            //
//  - automatic imports from different locations    //
//                                                  //
//////////////////////////////////////////////////////

import (
	"std.um"
	"strings.um"
)

//////////////////////////////////
// io

fn readall(f: std.File): str {
    const blockSize = 16
    res := ""

    for ok := true; ok {
	    var buff: [blockSize + 1]char
	    ok = std.fread(f, ^[blockSize]char(&buff)) == 1
	    res += str([]char(buff))
    }

    return res
}


//////////////////////////////////
// c conversion

fn strtoc(inp: str): str {
	out := ""
	splt := strings.split(inp, "\n")

	for i:=0; i < len(splt); i++ {
		tmp := strings.replace(splt[i], "\\", "\\\\")
		out += "\"" + strings.replace(tmp, "\"", "\\\"") + "\\n\"\n"
	}

	return out
}

//////////////////////////////////
// dependencies

fn trimdep(inp: str): str {
	out := ""
	for i:=0; i < len(inp); i++ {
		if !(inp[i] == ' ' || inp[i] == '\"' || inp[i] == '\t') {
			out += inp[i]
		}
	}
	return out
}

fn getdeps(fname: str): []str {
	f := std.fopen(fname, "r")
	if f == null {
		return []str{}
	}
	inp := readall(f)
	std.fclose(f)

	split := strings.split(inp, "\n")
	out := []str{}

	for i:=0; i < len(split); i++ {
		if strings.contains(split[i], "import") && split[i][0] == 'i' {
			if strings.contains(split[i], "(") {
				for j:=1; j < len(split) && !strings.contains(split[i+j], ")"); j++ {
					if strings.contains(split[i+j], "\"") {
						out = append(out, trimdep(split[i+j]))
					}
				}
				return out
			}
			if lsplit := strings.split(split[i], " "); len(lsplit) > 1 {
				out = append(out, lsplit[1])
				return out
			}
		}
	}
	return out
}

fn mergedeps(inp1, inp2: []str): []str {
	for i:=0; i < len(inp2); i++ {
		canadd := true
		for j:=0; j < len(inp1); j++ {
			if inp1[j] == inp2[i] {
				canadd = false
				break
			}
		}
		if canadd {
			inp1 = append(inp1, inp2[i])
		}
	}
	return inp1
}

fn deplist(dir, inp: str): []str {
	out := getdeps(dir+inp)
	for i:=0; i < len(out); i++ {
		deps := deplist(dir, out[i])
		out = mergedeps(deps, out)
	}
	return out
}

fn getdir(inp: str): str {
	split := strings.split(inp, "/")
	return strings.join(slice(split, 0, len(split)-1), "/")
}

//////////////////////////////////
// rest

fn help() {
	printf("umka2bin. Public domain umka into c embedder by Marek Maskarinec.\n")
	printf("source code: https://github.com/marekmaskarinec/libs/blob/main/umka2bin.um\n")
	printf("usage:\n")
	printf("    Pass the file, that contains the main function. Dependencies will get fetches automatically, if they are in the same folder.\n")
	printf("    Build it using `cc source.c -o name -L. -lumka -lm -ldl`. Supply your own libumka.a and umka_api.h.\n")
}

fn main() {
	if std.argc() == 0 {
		help()
		return
	}

	argoff := 0
	if std.argv(0) == "umka" {
		argoff = 1
	}

	if std.argc() < 2 + argoff {
		help()
		return
	}

	files := []str{std.argv(argoff+1)}
	files = append(files, deplist(getdir(files[0]), files[0]))

	includes := "#include \"umka_api.h\"\n#include <stdio.h>\n"

	header := "int main(int argc, char **argv) {\n	int umkaInitBodies = 0, umkaDrawBodies = 0;\n	void *umka = umkaAlloc();\n"

	header += "int umkaOk = umkaInit(umka, \"" + std.argv(argoff+1) + "\"," + "libs[0]" + " , 1024 * 1024, 1024 * 1024, argc, argv);\n"

	compile := "if (!umkaOk) {\n		printf(\"could not initialize umka\\n\");\n		return 1;\n	}\n	umkaOk = umkaCompile(umka);\n	if (!umkaOk) {\n		UmkaError error;\n		umkaGetError(umka, &error);\n		printf(\"Umka error %s (%d, %d): %s\\n\", error.fileName, error.line, error.pos, error.msg);\n		return 1;\n	}\n	umkaOk = umkaRun(umka);\n	if (!umkaOk) {\n		UmkaError error;\n		umkaGetError(umka, &error);\n		printf(\"Umka runtime error %s (%d): %s\\n\", error.fileName, error.line, error.msg);\n	}        \n	umkaFree(umka);\n}\n"

	libdata := "const char *libs[] = {\n"
	moddata := ""

	for i:=0; i < len(files); i++ {
		f := std.fopen(files[i], "r")
		libdata += strtoc(readall(f)) + ","
		if i != 0 {
			moddata += "umkaAddModule(umka, \"" + files[i] + "\", libs[" + repr(i) + "]);\n"
		}
		std.fclose(f)
	}
	libdata += "};\n"

	printf("%s", includes)
	printf("%s", libdata)
	printf("%s", header)
	printf("%s", moddata)
	printf("%s", compile)
}
