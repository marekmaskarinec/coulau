//////////////////////////////////////////////////////////////
//                                                          //
// json.um - public domain json parser for umka             //
// by Marek Maskarinec                                      //
// https://github.com/marekmaskarinec/libs                  //
//                                                          //
// How to use:                                              //
//   First you need to replace map.um and std.um            //
//   for the location, where you have them. Then            //
//   you can use the parse function. It takes a             //
//   string for input and returns an interface.             //
//   The interface is either []interface{}, or              //
//   map.Map.                                               //
//                                                          //
// TODO:                                                    //
//   Benchmark this.                                        //
//                                                          //
//////////////////////////////////////////////////////////////

import (
	"map.um" // change me for your map.um location
	"std.um" // change me for your std.um location
)

const ( // @vtereshkov please add enum :]
	tok_opener    = 0
	tok_closer    = 1
	tok_colon     = 2
	tok_str       = 3
	tok_int       = 4
	tok_real      = 5
	tok_bool      = 6
	tok_separator = 7
	tok_lopener   = 8
	tok_lcloser   = 9
)

type lexer = struct {
	inp: str
	pos: int
}

type token = struct {
	t: int
	pos: int // maybe add line numbers
	value: str
}

fn (l: ^lexer) get(): char {
	if l.pos >= len(l.inp) { return '\0' } // @vtereshkov please add EOF
	l.pos++
	return l.inp[l.pos-1]
}

fn (l: ^lexer) lex_str(): str {
	out := ""
	for true {
		c := l.get()

		if l.pos > 1 && c == '"' && l.inp[l.pos-2] != '\\' {
			break
		}

		out += c
	}
	return out
}

fn is_num(inp: char): bool {
	return ((inp >= '0' && inp <= '9') || inp == '.')
}

fn (l: ^lexer) lex_num(): (str, bool) {
	out := ""
	is_real := false

	for true {
		c := l.get()
		if c == '.' { is_real = true }
		if !is_num(c) { break }
		out += c
	}

	return out, is_real 
}

fn (l: ^lexer) lex_space(): str {
	out := ""
	for c := l.get(); c != ' ' {
		out += c
	}
	return out
}

fn (l: ^lexer) lex_next(): (token, bool) {
	for l.pos < len(l.inp) && (l.inp[l.pos] == ' ' || l.inp[l.pos] == '\n') {
		l.pos++
	}

	switch l.get() {
	case '{':
		return token{tok_opener, l.pos, "{"}, true
	case '}':
		return token{tok_closer, l.pos, "}"}, true
	case '[':
		return token{tok_lopener, l.pos, "["}, true
	case ']':
		return token{tok_lcloser, l.pos, "]"}, true
	case '"': // are ' or ` strings allowed?
		return token{tok_str, l.pos, l.lex_str()}, true
	case '\0':
		return token{}, false
	case ':':
		return token{tok_colon, l.pos, str(l.inp[l.pos-1])}, true
	case ',':
		return token{tok_separator, l.pos, str(l.inp[l.pos-1])}, true
	default:
		if is_num(l.inp[l.pos-1]) {
			first := l.inp[l.pos-1]
			val, is_real := l.lex_num()
			t := tok_int
			if is_real { t = tok_real }
			l.pos--
			return token{t, l.pos, first + val}, true
		}

		return token{tok_bool, l.pos, l.lex_space()}, true
	}

	return token{}, false
}

fn parser_error(msg: str) {
	printf("error: %s\n", msg)
}

fn (l: ^lexer) parse_object(): map.Map

fn (l: ^lexer) parse_val(): interface{} {
	t, stay := l.lex_next()
	switch (t.t) {
	case tok_str:
		return t.value
	case tok_int:
		return std.atoi(t.value)
	case tok_real:
		return std.atof(t.value)
	case tok_opener:
		return l.parse_object()
	default:
		parser_error("unsupported json feature")
	}

	return null
}

fn (l: ^lexer) parse_object(): map.Map {
	var key: str
	var val: interface{}
	var out: map.Map
	
	// this looks horrible
	t, stay := l.lex_next()
	for stay && t.t != tok_closer {
		if t.t == tok_str {
			next, stay := l.lex_next()
			if next.t != tok_colon {
				parser_error("missing colon")
				break
			}
			key = t.value
			val = l.parse_val()
			next, stay = l.lex_next()
			if stay && next.t != tok_separator && next.t != tok_closer {
				parser_error("missing comma.")
				printf("%s %d\n", repr(next), l.pos)
			}
			if next.t == tok_closer {
				break
			}
			out.set(key, val)
		}
		t, stay = l.lex_next()
	}

	return out
}

fn (l: ^lexer) parse_array(): []interface{} {
	out := []interface{}{} // todo allocate before parsing

	stay := true
	t := token{}
	for stay && t.t != tok_lcloser {
		out = append(out, l.parse_val())
		t, stay = l.lex_next()

		if stay && (t.t != tok_separator && t.t != tok_lcloser) {
			parser_error("array elements are not separated correctly")
			printf("%s %d\n", repr(t), l.pos)
			break
		}
	}

	return out
}

// parser json provided as an input and returns either map.Map or []interface{}
fn parse*(inp: str): interface{} {
	l := lexer{inp, 0}

	t, end := l.lex_next()
	var out: interface{}

	switch (t.t) {
	case tok_opener:
		out = l.parse_object()
	case tok_lopener:
		out = l.parse_array()
	default:
		parser_error("top level type can only be an object or an array")
	}

	return out
}
