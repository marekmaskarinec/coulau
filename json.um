///////////////////////////////////////////////////////
//                                                   //
// json.um - public domain json parser for umka      //
// by Marek Maskarinec                               //
// https://github.com/marekmaskarinec/libs           //
//                                                   //
// How to use:                                       //
//   First you need to replace map.um and std.um     //
//   for the location, where you have them. Then     //
//   you can use the parse function. It takes a      //
//   string for input and returns an interface.      //
//   The interface is either []interface{}, or       //
//   map.Map.                                        //
//                                                   //
// TODO:                                             //
//   improve performance                             //
//                                                   //
// Disclaimer:                                       //
//   this doesn't adhere to json specs perfectly and //
//   check for errors much. Please pass it correct   //
//   json :]                                         //
//                                                   //
///////////////////////////////////////////////////////

import (
	"map.um" // change me for your map.um location
	"std.um" // change me for your std.um location
)

const ( // @vtereshkov please add enum :]
	tok_null      = 0
	tok_opener    = 1
	tok_closer    = 2
	tok_colon     = 3
	tok_str       = 4
	tok_int       = 5
	tok_real      = 6
	tok_const     = 7
	tok_separator = 8
	tok_lopener   = 9
	tok_lcloser   = 10
)

type lexer = struct {
	inp: str
	pos: int
	lineno: int
}

type token = struct {
	t: int
	pos: int
	value: str
}

fn (l: ^lexer) get(): char {
	if l.pos >= len(l.inp) { return '\0' } // @vtereshkov please add EOF
	l.pos++
	return l.inp[l.pos-1]
}

fn (l: ^lexer) lex_str(): str {
	out := ""
	for true {
		c := l.get()

		if l.pos > 1 && c == '"' && l.inp[l.pos-2] != '\\' {
			break
		}

		out += c
	}
	return out
}

fn is_num(inp: char): bool {
	return ((inp >= '0' && inp <= '9') || inp == '.')
}

fn (l: ^lexer) lex_num(): (str, bool) {
	out := ""
	is_real := false

	for true {
		c := l.get()
		if c == '.' { is_real = true }
		if !is_num(c) { break }
		out += c
	}

	return out, is_real 
}

fn (l: ^lexer) lex_space(): str {
	out := ""
	l.pos--
	c := l.get()
	for c != ' ' && c != '}' && c != ']' && c != '\n' && c != ',' {
		out += c
		c = l.get()
	}
	l.pos--
	return out
}

fn (l: ^lexer) lex_next(): (token, bool) {
	for l.pos < len(l.inp) && (l.inp[l.pos] == ' ' || l.inp[l.pos] == '\n' || l.inp[l.pos] == '\t') {
		if l.inp[l.pos] == '\n' {
			l.lineno++
		}
		l.pos++
	}

	switch l.get() {
	case '{':
		return token{tok_opener, l.pos, "{"}, true
	case '}':
		return token{tok_closer, l.pos, "}"}, true
	case '[':
		return token{tok_lopener, l.pos, "["}, true
	case ']':
		return token{tok_lcloser, l.pos, "]"}, true
	case '"': // are ' or ` strings allowed?
		return token{tok_str, l.pos, l.lex_str()}, true
	case '\0':
		return token{}, false
	case ':':
		return token{tok_colon, l.pos, str(l.inp[l.pos-1])}, true
	case ',':
		return token{tok_separator, l.pos, str(l.inp[l.pos-1])}, true
	default:
		if is_num(l.inp[l.pos-1]) || l.inp[l.pos-1] == '-' {
			first := l.inp[l.pos-1]
			val, is_real := l.lex_num()
			t := tok_int
			if is_real { t = tok_real }
			l.pos--
			return token{t, l.pos, first + val}, true
		}

		val := l.lex_space()
		if val == "true" || val == "false" || val == "null" {
			return token{tok_const, l.pos, val}, true
		}

		return token{}, true
	}

	return token{}, false
}

fn parser_error(msg: str) {
	printf("error: %s\n", msg)
}

fn (l: ^lexer) parse_object(): map.Map
fn (l: ^lexer) parse_array(): []interface{}

fn (l: ^lexer) parse_val(): interface{} {
	t, stay := l.lex_next()
	switch (t.t) {
	case tok_str:
		return t.value
	case tok_int:
		return std.atoi(t.value)
	case tok_real:
		return std.atof(t.value)
	case tok_opener:
		return l.parse_object()
	case tok_lopener:
		return l.parse_array()
	case tok_const:
		if t.value == "true" {
			return true
		} else if t.value == "false" {
			return false
		} else if t.value == "null" {
			return null
		}
	default:
		parser_error("unsupported json feature")
		printf("%s %d\n", repr(t), l.lineno)
	}

	return null
}

fn (l: ^lexer) parse_object(): map.Map {
	var key: str
	var val: interface{}
	var out: map.Map
	
	// this looks horrible
	t, stay := l.lex_next()
	for stay && t.t != tok_closer {
		if t.t == tok_str {
			next, stay := l.lex_next()
			if next.t != tok_colon {
				parser_error("missing colon")
				break
			}
			key = t.value
			val = l.parse_val()
			next, stay = l.lex_next()
			if stay && next.t != tok_separator && next.t != tok_closer {
				parser_error("missing comma.")
				printf("%s %d\n", repr(next), l.lineno)
			}
			if next.t == tok_closer {
				break
			}
			out.set(key, val)
		}
		t, stay = l.lex_next()
	}

	return out
}

fn (l: ^lexer) parse_array(): []interface{} {
	out := []interface{}{} // todo allocate before parsing

	stay := true
	t := token{}
	for stay && t.t != tok_lcloser {
		out = append(out, l.parse_val())
		t, stay = l.lex_next()

		if stay && (t.t != tok_separator && t.t != tok_lcloser) {
			parser_error("array elements are not separated correctly")
			printf("%s %d\n", repr(t), l.lineno)
			break
		}
	}

	return out
}

// parser json provided as an input and returns either map.Map or []interface{}
fn parse*(inp: str): interface{} {
	l := lexer{inp, 0, 0}

	t, end := l.lex_next()
	var out: interface{}

	switch (t.t) {
	case tok_opener:
		out = l.parse_object()
	case tok_lopener:
		out = l.parse_array()
	default:
		parser_error("top level type can only be an object or an array")
	}

	return out
}
